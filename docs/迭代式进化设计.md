# 迭代式进化系统设计

## 1. 问题分析

### 当前系统的局限性
1. **一次性生成**：每次尝试都完全重新生成代码，没有利用之前的失败经验
2. **无错误反馈**：AI 不知道之前哪里出错，只能盲目重试
3. **无渐进式改进**：不支持从简单到复杂的逐步完善
4. **复杂能力难以实现**：如网络搜索这样的复杂功能，单次生成很难成功

### 实际案例（网络搜索能力）
- 第1次：测试生成失败（API 超时）
- 第2次：测试执行异常（代码 bug）
- 第3次：测试通过率 33%（http_request 超时）
- **结果**：3次尝试后失败，但每次都在不同地方进步

## 2. 迭代式进化架构

### 2.1 核心理念
```
简单尝试 → 测试 → 发现问题 → 反馈改进 → 再测试 → 逐步完善
```

### 2.2 迭代流程设计

```
第0次（分解）: 分析需求 → 制定实施计划 → 确定迭代策略
    ↓
第1次（基础版本）: 生成最简单的可工作版本
    ↓ 测试
    ├─ 成功 → 进入第2次
    └─ 失败 → 收集错误信息 → 反馈改进 → 重试第1次
    ↓
第2次（功能完善）: 基于第1次的代码，添加更多功能
    ↓ 测试
    ├─ 成功 → 进入第3次
    └─ 失败 → 收集错误信息 → 反馈改进 → 重试第2次
    ↓
第3次（错误处理）: 添加异常处理和边界情况
    ↓ 测试
    ├─ 成功 → 进入第4次
    └─ 失败 → 收集错误信息 → 反馈改进 → 重试第3次
    ↓
第4次（优化）: 性能优化、代码优化
    ↓ 测试
    ├─ 成功 → 完成 ✅
    └─ 失败 → 回退到上一个成功版本
```

### 2.3 数据结构扩展

#### EvolutionGoal（进化目标）
```python
@dataclass
class EvolutionGoal:
    # 现有字段
    title: str
    description: str
    status: GoalStatus
    priority: GoalPriority
    acceptance_criteria: List[str]
    attempts: int
    max_attempts: int
    
    # 新增：迭代管理
    iteration_plan: Optional['IterationPlan'] = None  # 迭代计划
    iteration_history: List['IterationRecord'] = field(default_factory=list)  # 历史记录
    current_iteration: int = 0  # 当前迭代轮次
    best_version: Optional['CodeVersion'] = None  # 最佳版本
    
    # 新增：反馈机制
    current_issues: List[str] = field(default_factory=list)  # 当前问题
    improvement_suggestions: List[str] = field(default_factory=list)  # 改进建议
```

#### IterationPlan（迭代计划）
```python
@dataclass
class IterationPlan:
    """能力的迭代实施计划"""
    stages: List['IterationStage']  # 迭代阶段列表
    complexity_level: str  # simple | medium | complex
    estimated_iterations: int  # 预计迭代次数
    created_at: str
```

#### IterationStage（迭代阶段）
```python
@dataclass
class IterationStage:
    """单个迭代阶段"""
    stage_number: int  # 阶段编号
    stage_name: str  # 阶段名称（如 "基础实现"、"功能完善"）
    goals: List[str]  # 本阶段目标
    acceptance_criteria: List[str]  # 验收标准
    dependencies: List[str]  # 依赖的能力或库
    status: str  # pending | in_progress | completed | failed
```

#### IterationRecord（迭代记录）
```python
@dataclass
class IterationRecord:
    """单次迭代的记录"""
    iteration_number: int  # 迭代编号
    stage_number: int  # 所属阶段
    attempt_within_stage: int  # 阶段内第几次尝试
    
    # 输入
    guidance: str  # AI 指导语
    previous_code: Optional[str]  # 上一次的代码
    feedback: Optional[str]  # 反馈信息
    
    # 输出
    generated_code: str  # 生成的代码
    test_results: Dict[str, Any]  # 测试结果
    success: bool  # 是否成功
    
    # 分析
    issues_found: List[str]  # 发现的问题
    improvements_made: List[str]  # 改进点
    
    timestamp: str
```

#### CodeVersion（代码版本）
```python
@dataclass
class CodeVersion:
    """代码版本信息"""
    version: str  # 版本号（如 "1.0", "1.1"）
    code: str  # 代码内容
    test_pass_rate: float  # 测试通过率
    iteration_number: int  # 对应的迭代编号
    created_at: str
```

## 3. 关键组件设计

### 3.1 IterativeEvolver（迭代进化器）

```python
class IterativeEvolver:
    """迭代式进化器，负责管理多次迭代的进化过程"""
    
    def __init__(self, capability_generator, goal_manager):
        self.generator = capability_generator
        self.goal_manager = goal_manager
        
    def evolve_with_iterations(self, goal: EvolutionGoal) -> Dict[str, Any]:
        """
        对一个目标进行迭代式进化
        
        Returns:
            {
                "success": bool,
                "capability_id": str,
                "total_iterations": int,
                "final_stage": int,
                "best_version": CodeVersion,
                "message": str
            }
        """
        # 1. 制定迭代计划
        plan = self._create_iteration_plan(goal)
        goal.iteration_plan = plan
        
        # 2. 逐阶段执行
        for stage in plan.stages:
            stage_result = self._execute_stage(goal, stage)
            
            if not stage_result["success"]:
                # 阶段失败，尝试重试或回退
                if stage.stage_number == 1:
                    # 第一阶段失败，整体失败
                    return self._failure_result(goal, "第一阶段失败")
                else:
                    # 回退到上一个成功阶段
                    return self._finalize_with_best_version(goal)
            
            # 阶段成功，继续下一阶段
            stage.status = "completed"
        
        # 3. 所有阶段完成
        return self._success_result(goal)
    
    def _create_iteration_plan(self, goal: EvolutionGoal) -> IterationPlan:
        """
        基于目标复杂度制定迭代计划
        
        策略：
        - 简单任务：1-2个阶段
        - 中等任务：3-4个阶段  
        - 复杂任务：4-5个阶段
        """
        complexity = self._estimate_complexity(goal)
        
        if complexity == "simple":
            stages = [
                IterationStage(1, "完整实现", [...], [...], [], "pending")
            ]
        elif complexity == "medium":
            stages = [
                IterationStage(1, "基础实现", [...], [...], [], "pending"),
                IterationStage(2, "功能完善", [...], [...], [], "pending"),
                IterationStage(3, "错误处理", [...], [...], [], "pending")
            ]
        else:  # complex
            stages = [
                IterationStage(1, "基础框架", [...], [...], [], "pending"),
                IterationStage(2, "核心功能", [...], [...], [], "pending"),
                IterationStage(3, "扩展功能", [...], [...], [], "pending"),
                IterationStage(4, "错误处理", [...], [...], [], "pending"),
                IterationStage(5, "优化完善", [...], [...], [], "pending")
            ]
        
        return IterationPlan(
            stages=stages,
            complexity_level=complexity,
            estimated_iterations=len(stages) * 2,  # 每阶段预计2次尝试
            created_at=datetime.now().isoformat()
        )
    
    def _execute_stage(self, goal: EvolutionGoal, stage: IterationStage) -> Dict:
        """
        执行单个迭代阶段
        
        一个阶段内允许多次尝试（最多3次）
        """
        max_attempts_per_stage = 3
        previous_code = goal.best_version.code if goal.best_version else None
        
        for attempt in range(1, max_attempts_per_stage + 1):
            # 生成本次的指导语（包含反馈）
            guidance = self._generate_stage_guidance(
                goal, stage, previous_code, attempt
            )
            
            # 调用 AI 生成代码
            result = self.generator.generate_capability(
                guidance=guidance,
                context={
                    "previous_code": previous_code,
                    "stage_info": stage,
                    "previous_issues": goal.current_issues
                }
            )
            
            # 记录迭代
            record = IterationRecord(
                iteration_number=goal.current_iteration + 1,
                stage_number=stage.stage_number,
                attempt_within_stage=attempt,
                guidance=guidance,
                previous_code=previous_code,
                feedback=self._generate_feedback(goal),
                generated_code=result.get("code", ""),
                test_results=result.get("test_results", {}),
                success=result["success"],
                issues_found=self._extract_issues(result),
                improvements_made=[],
                timestamp=datetime.now().isoformat()
            )
            goal.iteration_history.append(record)
            goal.current_iteration += 1
            
            if result["success"]:
                # 成功，更新最佳版本
                goal.best_version = CodeVersion(
                    version=f"{stage.stage_number}.{attempt}",
                    code=result["code"],
                    test_pass_rate=result.get("test_pass_rate", 0),
                    iteration_number=goal.current_iteration,
                    created_at=datetime.now().isoformat()
                )
                return {"success": True, "result": result}
            
            # 失败，更新问题列表
            goal.current_issues = self._extract_issues(result)
            previous_code = result.get("code") if result.get("code") else previous_code
        
        # 多次尝试后仍失败
        return {"success": False, "error": "阶段多次尝试后失败"}
    
    def _generate_stage_guidance(self, goal, stage, previous_code, attempt):
        """
        生成包含上下文和反馈的指导语
        
        第1次尝试：只包含阶段目标
        第2次+：包含上次的错误和改进建议
        """
        guidance = f"""
# 目标：{goal.title}
## 当前阶段：{stage.stage_name} (阶段 {stage.stage_number})

### 本阶段目标
{chr(10).join(f"- {g}" for g in stage.goals)}

### 验收标准
{chr(10).join(f"- {c}" for c in stage.acceptance_criteria)}
"""
        
        if attempt > 1 and previous_code:
            guidance += f"""

### 上一次的代码存在以下问题
{chr(10).join(f"- {issue}" for issue in goal.current_issues)}

### 改进建议
请基于上次的代码进行改进，重点解决上述问题。

### 上次的代码
```python
{previous_code}
```
"""
        
        return guidance
    
    def _estimate_complexity(self, goal: EvolutionGoal) -> str:
        """
        评估目标复杂度
        
        基于：
        - 描述长度
        - 验收标准数量
        - 关键词分析
        """
        desc_length = len(goal.description)
        criteria_count = len(goal.acceptance_criteria)
        
        # 关键词
        complex_keywords = ["网络", "数据库", "API", "搜索", "爬虫", "并发", "异步"]
        has_complex_keyword = any(kw in goal.description for kw in complex_keywords)
        
        if criteria_count >= 5 or has_complex_keyword:
            return "complex"
        elif criteria_count >= 3 or desc_length > 200:
            return "medium"
        else:
            return "simple"
```

### 3.2 集成到现有系统

#### 修改 goal_evolution.py

```python
def _execute_goal(self, goal):
    """执行单个目标（使用迭代式进化）"""
    print("\n" + "=" * 70)
    print(f"📎 目标: {goal.title}")
    print(f"   优先级: {goal.priority.value}")
    print("=" * 70)
    
    # 使用迭代进化器
    evolver = IterativeEvolver(
        capability_generator=self.capability_generator,
        goal_manager=self.goal_manager
    )
    
    result = evolver.evolve_with_iterations(goal)
    
    if result['success']:
        print(f"\n✅ 进化成功!")
        print(f"   总迭代次数: {result['total_iterations']}")
        print(f"   最终阶段: {result['final_stage']}")
        
        self.goal_manager.mark_goal_completed(goal, [result['capability_id']])
    else:
        print(f"\n❌ 进化失败: {result.get('error', '未知')}")
        self.goal_manager.mark_goal_failed(goal, result.get('error', ''))
```

## 4. AI Prompt 优化

### 4.1 初次生成 Prompt
```
你是一个能力代码生成器。请根据以下需求生成 Python 代码。

**重要**：这是第一次尝试，请先实现最简单、最核心的功能，确保代码能够运行。
不要一次性实现所有功能，先把基础打好。

需求：{description}

本阶段目标：{stage_goals}

请生成：
1. 清晰的函数定义
2. 基本的错误处理
3. 简单但完整的实现

返回 JSON 格式...
```

### 4.2 改进迭代 Prompt
```
你是一个能力代码改进器。需要改进之前生成的代码。

**上次代码的问题**：
{issues}

**改进目标**：
{improvement_goals}

**上次的代码**：
```python
{previous_code}
```

请改进代码，重点解决上述问题。保持代码的基本结构，只修改有问题的部分。

返回 JSON 格式...
```

## 5. 优势分析

### 5.1 相比当前系统
| 维度 | 当前系统 | 迭代式系统 |
|------|----------|-----------|
| 成功率 | 低（一次成功或失败） | 高（多次尝试，渐进改进） |
| 学习能力 | 无 | 从错误中学习 |
| 复杂度支持 | 仅适合简单任务 | 支持复杂任务 |
| 可调试性 | 差（无历史记录） | 好（完整历史） |
| 资源消耗 | 低 | 中等（多次调用） |

### 5.2 典型场景对比

**场景：网络搜索能力**

当前系统：
```
尝试1 → 失败（测试生成失败）→ 放弃
尝试2 → 失败（代码bug）→ 放弃  
尝试3 → 失败（超时）→ 完全失败
```

迭代系统：
```
阶段1：基础框架
  尝试1.1 → 生成基本的HTTP请求函数 → 成功 ✅
  
阶段2：搜索功能
  尝试2.1 → 添加搜索逻辑 → 失败（解析错误）
  尝试2.2 → 改进解析逻辑 → 成功 ✅
  
阶段3：错误处理
  尝试3.1 → 添加超时处理 → 成功 ✅
  
结果：成功！总共6次尝试，3个阶段完成
```

## 6. 实施计划

### 阶段1：核心组件（1-2天）
- [ ] 扩展 EvolutionGoal 数据模型
- [ ] 实现 IterativeEvolver 类
- [ ] 添加迭代计划生成逻辑

### 阶段2：集成（1天）
- [ ] 修改 goal_evolution.py
- [ ] 调整 CapabilityGenerator
- [ ] 优化 AI Prompt

### 阶段3：测试（1天）
- [ ] 用简单能力测试
- [ ] 用中等复杂度能力测试
- [ ] 用复杂能力（网络搜索）测试

### 阶段4：优化（1天）
- [ ] 性能优化
- [ ] 日志和可视化
- [ ] 文档完善

## 7. 配置参数

```python
# config.json 新增配置
{
    "evolution": {
        "iterative_mode": true,  # 启用迭代模式
        "max_iterations_per_goal": 15,  # 单个目标最大迭代次数
        "max_attempts_per_stage": 3,  # 每阶段最大尝试次数
        "complexity_threshold": {
            "simple": {"criteria": 2, "description_length": 100},
            "medium": {"criteria": 4, "description_length": 300}
        },
        "enable_code_reuse": true,  # 启用代码复用
        "save_iteration_history": true  # 保存迭代历史
    }
}
```

## 8. 监控和日志

```
[进化开始] 目标: 网络搜索能力
  └─ [计划] 复杂度: complex, 预计5个阶段
  
[阶段1] 基础框架
  ├─ [尝试1.1] 生成代码 → 测试通过率: 100% ✅
  └─ [完成] 耗时: 45秒
  
[阶段2] 核心功能  
  ├─ [尝试2.1] 生成代码 → 测试失败: 解析错误
  ├─ [尝试2.2] 改进代码 → 测试通过率: 80% ✅
  └─ [完成] 耗时: 120秒
  
[阶段3] 扩展功能
  ├─ [尝试3.1] 生成代码 → 测试通过率: 100% ✅
  └─ [完成] 耗时: 60秒

[进化完成] 总耗时: 225秒, 总迭代: 4次, 成功率: 75%
```

## 9. 回退策略

如果某个阶段持续失败：

1. **3次尝试失败** → 停止该阶段，使用上一个成功版本
2. **第1阶段失败** → 整个目标失败（无基础版本）
3. **后续阶段失败** → 降级使用上一阶段的版本（部分功能）

## 10. 未来扩展

- **自适应迭代**：根据历史数据自动调整迭代策略
- **并行尝试**：同一阶段生成多个版本，选择最佳
- **增量学习**：建立能力库，复用已有组件
- **A/B测试**：对比不同迭代策略的效果
