# 迭代式进化系统 - 总结与使用指南

## 📋 系统概述

迭代式进化系统是对原智(YuanZhi)进化能力的重大升级，支持从简单到复杂的渐进式能力开发。

### 核心改进

**之前**：每次失败后完全重新生成，3次失败即放弃  
**现在**：分阶段迭代改进，每阶段可多次尝试，保留最佳版本

## 🏗️ 架构设计

### 新增组件

1. **iteration_models.py** - 数据模型
   - `IterationPlan`: 迭代计划
   - `IterationStage`: 迭代阶段  
   - `IterationRecord`: 迭代记录
   - `CodeVersion`: 代码版本
   - `IterationSummary`: 迭代总结

2. **iterative_evolver.py** - 迭代进化器
   - 复杂度评估
   - 迭代计划制定
   - 分阶段执行
   - 错误反馈机制

3. **扩展的 goal_manager.py** - 目标管理
   - `EvolutionGoal` 添加迭代支持
   - 历史记录追踪
   - 最佳版本管理

## 🔄 工作流程

```
目标分析 → 制定计划 → 阶段1 → 阶段2 → ... → 完成
                         ↓       ↓            ↓
                      尝试1-3  尝试1-3    尝试1-3
                         ↓       ↓            ↓
                      反馈改进  反馈改进   反馈改进
```

### 复杂度分级

| 级别 | 标准 | 阶段数 | 适用场景 |
|------|------|--------|----------|
| Simple | 验收标准≤2, 描述<150字 | 1 | 简单工具函数 |
| Medium | 验收标准3-4, 或含"文件"等关键词 | 3 | 数据处理、格式转换 |
| Complex | 验收标准≥5, 或含"网络""API"等关键词 | 4 | 网络请求、数据库操作 |

## 📦 已创建文件

1. `docs/迭代式进化设计.md` - 详细设计文档
2. `prokaryote_agent/iteration_models.py` - 数据模型(217行)
3. `prokaryote_agent/iterative_evolver.py` - 核心进化器(658行)
4. 修改: `prokaryote_agent/goal_manager.py` - 添加迭代字段

## 🚀 集成方案

### 方案 A: 配置开关（推荐）

在 `config.json` 中添加：

```json
{
  "evolution": {
    "mode": "iterative",  // "simple" | "iterative"
    "iterative_config": {
      "max_iterations_per_goal": 15,
      "max_attempts_per_stage": 3,
      "enable_code_reuse": true
    }
  }
}
```

在 `goal_evolution.py` 中：

```python
from prokaryote_agent.iterative_evolver import IterativeEvolver

def _execute_goal(self, goal):
    # 读取配置
    evolution_mode = self.config.get('evolution', {}).get('mode', 'simple')
    
    if evolution_mode == 'iterative':
        # 使用迭代式进化
        evolver = IterativeEvolver(self.generator, self.config.get('evolution', {}).get('iterative_config'))
        result = evolver.evolve_with_iterations(goal)
    else:
        # 使用原有的简单模式
        result = self._simple_evolve(goal)
    
    # 处理结果...
```

### 方案 B: 新命令行脚本

创建 `iterative_evolution.py`:

```python
#!/usr/bin/env python
"""迭代式进化脚本"""

from prokaryote_agent import init_prokaryote
from prokaryote_agent.goal_manager import EvolutionGoalManager
from prokaryote_agent.capability_generator import CapabilityGenerator
from prokaryote_agent.iterative_evolver import IterativeEvolver
from prokaryote_agent.storage import StorageManager

def main():
    # 初始化
    init_prokaryote()
    
    # 加载目标
    goal_manager = EvolutionGoalManager()
    goal_manager.load_goals()
    
    # 获取待执行目标
    next_goal = goal_manager.get_next_goal()
    if not next_goal:
        print("没有待执行的目标")
        return
    
    # 创建进化器
    storage = StorageManager()
    generator = CapabilityGenerator(storage)
    evolver = IterativeEvolver(generator)
    
    # 执行迭代进化
    print(f"开始迭代进化: {next_goal.title}")
    result = evolver.evolve_with_iterations(next_goal)
    
    if result['success']:
        print(f"✅ 成功!")
        print(f"  总迭代: {result['summary']['total_iterations']}")
        print(f"  测试通过率: {result['test_pass_rate']:.0%}")
        goal_manager.mark_goal_completed(next_goal, [result['capability_id']])
    else:
        print(f"❌ 失败: {result['error']}")

if __name__ == "__main__":
    main()
```

运行：`python iterative_evolution.py`

## 📊 效果对比

### 简单模式 vs 迭代模式

**示例：网络搜索能力**

| 维度 | 简单模式 | 迭代模式 |
|------|----------|----------|
| 尝试次数 | 3次 | 最多15次 |
| 成功率 | 0% (3次全失败) | 预计60-80% |
| 时间消耗 | 10分钟 | 15-25分钟 |
| 代码质量 | 低（未通过测试） | 高（渐进改进） |
| 可调试性 | 差（无历史） | 好（完整记录） |

## 🎯 典型使用场景

### 场景1：简单工具函数（Simple）

**目标**：实现一个计算斐波那契数列的函数

- 复杂度：Simple
- 阶段数：1
- 预计迭代：1-2次
- 预计时间：30-60秒

### 场景2：数据处理（Medium）

**目标**：解析CSV文件并统计数据

- 复杂度：Medium  
- 阶段数：3 (基础读取 → 数据解析 → 统计分析)
- 预计迭代：4-6次
- 预计时间：3-5分钟

### 场景3：网络功能（Complex）

**目标**：实现网络搜索能力

- 复杂度：Complex
- 阶段数：4 (HTTP请求 → 搜索逻辑 → 结果解析 → 错误处理)
- 预计迭代：6-12次
- 预计时间：10-20分钟

## ⚙️ 配置参数

```python
{
    "max_iterations_per_goal": 15,        # 单个目标最大迭代次数
    "max_attempts_per_stage": 3,          # 每阶段最大尝试次数
    "enable_code_reuse": true,            # 启用代码复用
    "complexity_threshold": {             # 复杂度阈值
        "simple": {
            "criteria": 2,
            "description_length": 150
        },
        "medium": {
            "criteria": 4,
            "description_length": 300
        }
    }
}
```

## 📝 迭代日志示例

```
[进化开始] 目标: 网络搜索能力
  └─ [计划] 复杂度: complex, 4个阶段, 预计8次迭代

[阶段1/4] 基础框架
  ├─ [尝试1.1] 生成HTTP请求函数
  │   └─ ✅ 成功 (测试通过率: 100%, 耗时45s)
  └─ [阶段完成]

[阶段2/4] 核心功能
  ├─ [尝试2.1] 实现搜索逻辑
  │   └─ ❌ 失败 (解析错误)
  ├─ [尝试2.2] 改进解析逻辑 [基于反馈]
  │   └─ ✅ 成功 (测试通过率: 80%, 耗时120s)
  └─ [阶段完成]

[阶段3/4] 扩展功能
  ├─ [尝试3.1] 添加多种搜索引擎支持
  │   └─ ✅ 成功 (测试通过率: 90%, 耗时90s)
  └─ [阶段完成]

[阶段4/4] 错误处理与完善
  ├─ [尝试4.1] 添加超时和重试机制
  │   └─ ✅ 成功 (测试通过率: 95%, 耗时60s)
  └─ [阶段完成]

[进化完成] 
  ✅ 成功! 
  - 总迭代次数: 5
  - 成功率: 80% (4/5)
  - 最终测试通过率: 95%
  - 总耗时: 315秒 (5分15秒)
  - 最佳版本: 4.1
```

## 🔍 监控与调试

### 查看迭代历史

```python
# 获取目标的迭代历史
for record in goal.iteration_history:
    print(f"迭代 {record.iteration_number}:")
    print(f"  阶段: {record.stage_number}")
    print(f"  成功: {record.success}")
    print(f"  问题数: {len(record.issues_found)}")
```

### 查看最佳版本

```python
if goal.best_version:
    print(f"最佳版本: {goal.best_version.version}")
    print(f"测试通过率: {goal.best_version.test_pass_rate:.0%}")
    print(f"代码长度: {len(goal.best_version.code)}")
```

## 🚧 后续计划

### 短期（1-2周）
- [ ] 集成到 goal_evolution.py（配置开关）
- [ ] 完善日志输出和可视化
- [ ] 用实际案例测试验证

### 中期（1个月）
- [ ] 添加迭代历史持久化
- [ ] 实现版本回退机制
- [ ] 优化 AI Prompt 模板

### 长期（2-3个月）
- [ ] 自适应迭代策略（根据历史数据）
- [ ] 并行尝试多个方案
- [ ] 建立能力组件库，支持复用

## 📚 相关文档

- [详细设计](./迭代式进化设计.md)
- [数据模型 API](../prokaryote_agent/iteration_models.py)
- [进化器 API](../prokaryote_agent/iterative_evolver.py)

## 💡 使用建议

1. **从简单开始**：先用简单目标测试系统
2. **合理设置验收标准**：过多标准会增加复杂度
3. **监控迭代过程**：查看日志，了解进化进度
4. **保留历史记录**：便于分析和改进
5. **适当调整配置**：根据实际情况调整参数

---

**状态**: ✅ 核心组件已完成，待集成测试

**下一步**: 集成到 goal_evolution.py 并用网络搜索能力验证
