# 通用技能树设计方案

## 1. 设计理念

### 1.1 通用技能 vs 专业技能

| 维度 | 通用技能 | 专业技能 |
|------|---------|---------|
| 定位 | 基础能力，支撑所有领域 | 领域深耕，专业产出 |
| 方向 | 知识获取 + 外界交互 | 领域知识 + 专业输出 |
| 优先级 | 前期优先，是根基 | 后期深化，是特长 |
| 进化方式 | AI动态优化调整 | 按领域技能树固定路径 |

### 1.2 核心原则

1. **根基优先**：没有强大的通用能力，专业技能无法发挥
2. **相辅相成**：通用技能提供工具，专业技能提供方向
3. **动态进化**：通用技能树随Agent能力成长而自我优化

## 2. 通用技能分类

### 2.1 知识获取能力 (Knowledge Acquisition)

**目标**：丰富获取知识的手段，扩大知识来源

```
知识获取能力
├── 搜索能力 (Search)
│   ├── web_search_basic         # 基础网络搜索
│   ├── web_search_advanced      # 高级搜索（多引擎、语义搜索）
│   ├── academic_search          # 学术搜索（论文、专利）
│   └── vertical_search          # 垂直搜索（特定领域数据库）
│
├── 内容获取 (Content Fetching)
│   ├── web_scraping_basic       # 基础网页抓取
│   ├── web_scraping_advanced    # 高级抓取（JS渲染、反爬绕过）
│   ├── api_integration          # API集成（REST/GraphQL）
│   └── data_source_connector    # 数据源连接器（数据库、文件）
│
├── 内容解析 (Content Parsing)
│   ├── html_parser              # HTML解析
│   ├── document_parser          # 文档解析（PDF/Word/Excel）
│   ├── structured_data_parser   # 结构化数据解析（JSON/XML/CSV）
│   └── multimedia_parser        # 多媒体解析（图片OCR、音频转文字）
│
└── 知识提取 (Knowledge Extraction)
    ├── entity_extraction        # 实体提取
    ├── relation_extraction      # 关系提取
    ├── summary_generation       # 摘要生成
    └── knowledge_structuring    # 知识结构化
```

### 2.2 外界交互能力 (World Interaction)

**目标**：扩展与真实世界的交互能力

```
外界交互能力
├── 文件操作 (File Operations)
│   ├── file_read_write          # 文件读写
│   ├── file_management          # 文件管理（创建/删除/移动）
│   └── archive_handling         # 压缩包处理
│
├── 代码执行 (Code Execution)
│   ├── python_execution         # Python代码执行
│   ├── shell_execution          # Shell命令执行
│   └── sandbox_execution        # 沙箱执行（安全隔离）
│
├── 外部服务 (External Services)
│   ├── http_client              # HTTP客户端
│   ├── email_integration        # 邮件收发
│   ├── message_integration      # 消息服务（Slack/Discord/微信）
│   └── cloud_service_integration # 云服务集成
│
└── 数据持久化 (Data Persistence)
    ├── local_storage            # 本地存储
    ├── database_operations      # 数据库操作
    └── cloud_storage            # 云存储
```

### 2.3 自我进化能力 (Self Evolution)

**目标**：提升自我改进和适应能力

```
自我进化能力
├── 代码能力 (Code Capabilities)
│   ├── code_generation          # 代码生成
│   ├── code_analysis            # 代码分析
│   ├── code_refactoring         # 代码重构
│   └── code_testing             # 代码测试
│
├── 学习能力 (Learning)
│   ├── pattern_recognition      # 模式识别
│   ├── feedback_learning        # 反馈学习
│   └── transfer_learning        # 迁移学习
│
└── 优化能力 (Optimization)
    ├── performance_optimization # 性能优化
    ├── resource_optimization    # 资源优化
    └── strategy_optimization    # 策略优化
```

## 3. 进化优先级策略

### 3.1 阶段划分

```python
def get_evolution_priority(general_level_sum: int, domain_level_sum: int) -> dict:
    """
    根据当前能力水平决定进化优先级
    
    Returns:
        {'general': float, 'domain': float}  # 各占比例
    """
    total = general_level_sum + domain_level_sum
    
    # 萌芽期：总等级 < 30
    # 优先打好基础，通用能力占80%
    if total < 30:
        return {'general': 0.80, 'domain': 0.20}
    
    # 成长期：30 <= 总等级 < 100
    # 开始发展专业，但通用仍占主导
    elif total < 100:
        return {'general': 0.60, 'domain': 0.40}
    
    # 成熟期：100 <= 总等级 < 300
    # 均衡发展
    elif total < 300:
        return {'general': 0.40, 'domain': 0.60}
    
    # 专精期：总等级 >= 300
    # 专业深化，通用维护
    else:
        return {'general': 0.25, 'domain': 0.75}
```

### 3.2 技能选择算法

```python
def select_next_skill(general_tree, domain_tree, priority):
    """
    选择下一个要进化的技能
    
    考虑因素：
    1. 当前优先级（通用 vs 专业）
    2. 技能解锁状态
    3. 技能等级（优先低等级）
    4. 依赖关系（前置技能优先）
    5. 协同效应（与已有技能的配合）
    """
    # 按优先级加权随机选择类别
    if random.random() < priority['general']:
        tree = general_tree
    else:
        tree = domain_tree
    
    # 在选定类别中选择最优技能
    candidates = get_unlocked_skills(tree)
    return select_best_candidate(candidates)
```

## 4. AI动态优化机制

### 4.1 触发时机

1. **技能进化成功后**：评估新能力带来的可能性
2. **连续失败后**：分析能力短板，调整优先级
3. **阶段性评估**：每完成10次进化，全面评估

### 4.2 优化内容

```python
class GeneralTreeOptimizer:
    """通用技能树AI优化器"""
    
    def optimize_after_evolution(self, evolved_skill, context):
        """进化成功后优化"""
        
        # 1. 分析新获得的能力
        new_capabilities = self.analyze_new_capabilities(evolved_skill)
        
        # 2. 发现新的可能技能
        potential_skills = self.discover_potential_skills(new_capabilities)
        
        # 3. 调整技能优先级
        self.adjust_priorities(context)
        
        # 4. 更新技能解锁条件
        self.update_unlock_conditions()
        
        # 5. 生成优化报告
        return self.generate_report()
    
    def discover_potential_skills(self, capabilities):
        """AI发现潜在新技能"""
        prompt = f"""
        当前Agent已具备以下能力：
        {capabilities}
        
        请分析：
        1. 这些能力的组合可以衍生出哪些新的通用技能？
        2. 有哪些知识获取或外界交互能力是当前缺失的？
        3. 建议添加哪些新技能到通用技能树？
        
        返回JSON格式的建议。
        """
        return self.ai_analyze(prompt)
```

### 4.3 优化示例

**场景**：Agent成功进化了 `web_scraping_advanced` 技能

**AI分析**：
```json
{
  "new_capabilities": ["JS渲染页面抓取", "反爬虫绕过", "动态内容获取"],
  "synergy_effects": [
    "与 api_integration 结合可实现更完整的数据获取",
    "为 knowledge_extraction 提供更丰富的数据来源"
  ],
  "suggested_new_skills": [
    {
      "id": "browser_automation",
      "name": "浏览器自动化",
      "description": "控制浏览器执行复杂交互操作",
      "reason": "web_scraping_advanced已具备JS渲染能力，进一步发展可实现完整浏览器控制"
    }
  ],
  "priority_adjustments": [
    {"skill": "api_integration", "delta": +0.2, "reason": "与新能力协同效应强"}
  ]
}
```

## 5. 通用技能与专业技能的协同

### 5.1 能力支撑关系

```
通用技能                    专业技能（法律领域示例）
─────────────────────────────────────────────────
web_search_basic      →     legal_research_basic
  ↓                            ↓
web_scraping_basic    →     case_analysis_basic
  ↓                            ↓
document_parser       →     document_drafting_basic
  ↓                            ↓
knowledge_extraction  →     contract_review_intermediate
```

### 5.2 协同进化规则

1. **前置要求**：专业技能的进化可能依赖特定通用技能
   ```json
   {
     "legal_research_advanced": {
       "general_prerequisites": ["web_search_advanced", "academic_search"]
     }
   }
   ```

2. **能力加成**：通用技能等级影响专业技能效果
   ```python
   def calculate_skill_effectiveness(domain_skill, general_skills):
       base = domain_skill.level
       bonus = sum(g.level * 0.05 for g in related_general_skills)
       return base * (1 + bonus)
   ```

3. **知识共享**：通用技能获取的知识可被专业技能使用

## 6. 实现路线图

### Phase 1: 基础框架（1周）
- [ ] 创建通用技能树数据结构
- [ ] 实现基础通用技能（5个核心技能）
- [ ] 集成到现有进化系统

### Phase 2: 优先级系统（3天）
- [ ] 实现阶段性优先级计算
- [ ] 技能选择算法
- [ ] 通用/专业平衡逻辑

### Phase 3: AI优化器（1周）
- [ ] 实现 GeneralTreeOptimizer
- [ ] 技能发现机制
- [ ] 优先级动态调整

### Phase 4: 协同机制（3天）
- [ ] 通用-专业依赖关系
- [ ] 能力加成计算
- [ ] 知识共享系统

## 7. 初始通用技能树

```json
{
  "tree_id": "general_skills",
  "name": "通用技能树",
  "version": "1.0.0",
  "description": "Agent的基础能力，支撑所有专业领域",
  "categories": {
    "knowledge_acquisition": "知识获取",
    "world_interaction": "外界交互", 
    "self_evolution": "自我进化"
  },
  "skills": {
    "web_search_basic": {
      "name": "网络搜索",
      "category": "knowledge_acquisition",
      "tier": "basic",
      "level": 0,
      "max_level": 20,
      "description": "使用搜索引擎获取信息",
      "prerequisites": [],
      "unlocked": true
    },
    "web_scraping_basic": {
      "name": "网页抓取",
      "category": "knowledge_acquisition", 
      "tier": "basic",
      "level": 0,
      "max_level": 20,
      "description": "抓取和解析网页内容",
      "prerequisites": ["web_search_basic"],
      "unlocked": false
    },
    "file_operations": {
      "name": "文件操作",
      "category": "world_interaction",
      "tier": "basic",
      "level": 0,
      "max_level": 20,
      "description": "读写和管理文件系统",
      "prerequisites": [],
      "unlocked": true
    },
    "code_execution": {
      "name": "代码执行",
      "category": "world_interaction",
      "tier": "basic",
      "level": 0,
      "max_level": 20,
      "description": "执行Python/Shell代码",
      "prerequisites": ["file_operations"],
      "unlocked": false
    },
    "code_generation": {
      "name": "代码生成",
      "category": "self_evolution",
      "tier": "basic",
      "level": 0,
      "max_level": 20,
      "description": "生成和修改代码",
      "prerequisites": ["code_execution"],
      "unlocked": false
    }
  }
}
```

## 8. 核心接口设计

```python
class GeneralSkillTree:
    """通用技能树"""
    
    def get_category_skills(self, category: str) -> List[Skill]
    def get_unlocked_skills(self) -> List[Skill]
    def get_next_skill_to_evolve(self) -> Optional[Skill]
    def evolve_skill(self, skill_id: str) -> bool
    def get_total_level(self) -> int


class SkillEvolutionCoordinator:
    """技能进化协调器 - 统筹通用和专业技能"""
    
    def __init__(self, general_tree, domain_tree):
        self.general = general_tree
        self.domain = domain_tree
        self.optimizer = GeneralTreeOptimizer()
    
    def select_next_evolution(self) -> Tuple[str, Skill]:
        """选择下一个进化目标，返回(类型, 技能)"""
        priority = self.calculate_priority()
        # ...
    
    def on_evolution_success(self, skill_type, skill):
        """进化成功回调"""
        if skill_type == 'general':
            self.optimizer.optimize_after_evolution(skill, self.get_context())
    
    def get_evolution_stats(self) -> dict:
        """获取进化统计"""
        return {
            'general_level': self.general.get_total_level(),
            'domain_level': self.domain.get_total_level(),
            'priority': self.calculate_priority(),
            'stage': self.get_current_stage()
        }
```
