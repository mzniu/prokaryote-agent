prokaryote-agent 初步原始核心概要设计（Python+本地文件系统）

一、文档基础信息

项目名称

prokaryote-agent（原核生物启发型自主进化Agent内核）

概要设计版本

V1.0（初步原始核心版）

开发语言

Python 3.8+（轻量、易调试、适配本地文件操作）

存储方案

本地文件系统（文件夹+JSON/文本文件，无需数据库，贴合初步开发）

核心开发范围

初步原始核心（对应PRD V0.1原始存活版本）：初始化、状态感知、自我修复、核心特征存储（本地文件实现）

设计目标

架构极简、可落地，实现内核“存活”基础（状态监测+异常修复），适配Python轻量开发与本地文件存储

设计约束

1. 贴合原核生物极简逻辑，拒绝复杂架构；2. 仅依赖Python标准库（优先），减少第三方依赖；3. 存储基于本地文件，确保读写高效、配置简单；4. 聚焦V0.1核心功能，不提前开发变异、复制模块

适配环境

Windows/Linux/MacOS单机环境，Python 3.8+，本地磁盘可用空间≥100MB

二、总体设计

2.1 设计理念

类比原核生物“极简结构、存活优先”的特性，采用“模块化、轻量分层”设计，核心围绕“初始化→状态监测→异常修复→稳定运行”的闭环，全部基于Python实现，存储依赖本地文件系统，降低开发与部署成本，贴合“初步原始核心”的开发需求。

2.2 总体架构（3层架构，极简无冗余）

核心架构分为3层，层间调用简单直接，无复杂中间件，适配Python函数式调用逻辑，具体分层如下（从下到上）：

1. 存储层：基于本地文件系统，实现核心特征存储库的基础功能（备份、配置、日志存储），对应PRD中“核心特征存储库”，用本地文件夹+文件模拟“生物DNA存储”。

2. 核心模块层：实现V0.1版本必备核心模块（初始化模块、状态感知模块、自我修复模块），是内核的核心逻辑载体，模块间通过简单接口调用联动。

3. 接口层：提供极简外部接口（初始化、启动、停止、状态查询），供开发/运维人员调用，支撑内核启动、运行监测与手动干预（贴合PRD中运维需求）。

2.3 总体运行流程（贴合V0.1原始存活逻辑）

1. 初始化阶段：调用初始化模块，读取本地文件中的核心配置、备份数据，初始化内核基准状态，完成存储目录校验（确保本地文件夹存在），启动状态感知模块。

2. 稳定运行阶段：状态感知模块实时监测内核自身状态（运行、资源）与基础环境状态（本地文件读写权限、磁盘空间），每1秒输出1次状态数据（贴合PRD监测频率）。

3. 异常处理阶段：若状态感知模块检测到异常（如模块报错、备份文件丢失、磁盘空间不足），立即输出异常信号，触发自我修复模块。

4. 修复阶段：自我修复模块调用本地文件中的备份数据，替换异常模块/配置，修复完成后，触发状态感知模块二次校验，确认内核回归基准状态。

5. 循环运行：修复成功后，回归稳定运行阶段；若修复失败（连续3次），输出紧急提示，暂停内核运行（贴合PRD修复失败逻辑），留存异常日志至本地文件。

三、核心模块设计（Python实现，聚焦V0.1）

所有模块均采用Python类+函数实现，优先使用标准库（os、sys、threading、json、logging），减少第三方依赖，确保轻量可落地；模块间接口极简，通过函数参数传递数据，无复杂通信逻辑。

3.1 初始化模块（ProkaryoteInit）

模块功能

内核启动的入口模块，负责初始化核心配置、校验本地存储目录、加载备份数据、设置基准状态，确保内核能够正常启动，贴合V0.1“存活基础”要求。

核心设计（Python实现要点）

- 核心属性：
        

  - config_path：本地核心配置文件路径（默认：./prokaryote_agent/config/config.json）

  - backup_path：本地备份目录路径（默认：./prokaryote_agent/backup/）

  - base_state：内核基准状态字典（存储运行基准参数、资源阈值等）

- 核心方法：
        

  - __init__()：初始化模块，指定配置、备份路径，初始化基准状态为空字典。

  - check_storage_dir()：校验本地存储目录（config、backup、log），若不存在则自动创建（使用os.makedirs），避免文件读写异常。

  - load_config()：读取本地config.json配置文件（JSON格式），解析核心参数（资源阈值、监测频率、修复次数上限），存入base_state。

  - load_backup()：读取本地backup目录下的备份文件（核心模块备份、配置备份），校验备份文件完整性，确保修复时可调用。

  - init_core()：统一执行初始化流程（校验目录→加载配置→加载备份→设置基准状态），返回初始化结果（成功/失败）与错误信息。

- 异常处理：初始化失败（如配置文件损坏、备份文件缺失），返回失败状态，输出详细日志，终止内核启动。

3.2 状态感知模块（ProkaryoteMonitor）

模块功能

实时监测内核自身运行状态与基础环境状态，输出状态数据、识别异常，为自我修复模块提供触发信号，对应PRD中“状态感知模块”的V0.1功能。

核心设计（Python实现要点）

- 核心属性：
        

  - base_state：从初始化模块传入的内核基准状态（用于异常判断）

  - monitor_interval：监测频率（默认1秒，可通过配置文件修改）

  - is_running：模块运行状态标识（True=运行，False=停止）

  - current_state：当前内核状态字典（存储实时运行数据）

- 核心方法：
        

  - __init__(base_state)：接收基准状态，初始化监测参数，启动监测线程（用threading.Thread，避免阻塞内核）。

  - monitor_self()：监测内核自身状态（Python进程状态、模块运行状态、资源消耗）：
            

    - 进程状态：通过os.getpid()获取内核进程ID，判断进程是否存活。

    - 模块状态：监测核心模块（初始化、自我修复）的运行标识，判断是否存在报错。

    - 资源消耗：通过psutil库（可选，优先标准库，若无则简化为内存占用估算）监测Python进程的内存、CPU占用，与基准阈值对比。

  - monitor_env()：监测基础环境状态（贴合V0.1极简需求）：
            

    - 本地文件权限：校验config、backup目录的读写权限（用os.access判断）。

    - 磁盘空间：校验本地磁盘可用空间，是否低于基准阈值（用os.statvfs判断）。

  - check_abnormal()：对比current_state与base_state，识别异常（如资源超标、模块报错、文件权限不足），返回异常标识、异常类型、异常模块。

  - start_monitor()：启动监测线程，循环执行monitor_self()、monitor_env()、check_abnormal()，每1秒更新1次current_state。

  - stop_monitor()：停止监测线程，设置is_running为False。

- 异常触发：检测到异常时，立即调用自我修复模块的repair()方法，传入异常信息，同时记录异常日志。

3.3 自我修复模块（ProkaryoteRepair）

模块功能

接收状态感知模块的异常信号，调用本地文件中的备份数据，完成异常修复，校验修复结果，确保内核回归稳定状态，对应PRD中“自我修复模块”的V0.1功能。

核心设计（Python实现要点）

- 核心属性：


  - backup_path：本地备份目录路径（从初始化模块传入）

  - repair_max_count：修复最大次数（默认3次，可通过配置文件修改）

  - monitor_module：状态感知模块实例（用于修复后二次校验）

- 核心方法：
        

  - __init__(backup_path, monitor_module)：接收备份路径、状态感知模块实例，初始化修复参数。

  - get_backup(file_name)：根据异常模块/配置，读取本地backup目录下对应的备份文件（如核心模块备份.py、配置备份.json），返回备份数据。

  - repair(abnormal_info)：核心修复方法，根据异常类型执行对应修复逻辑：
            

    - 模块异常：调用get_backup()获取对应模块备份，替换当前异常模块（Python函数重加载）。

    - 配置异常：读取配置备份文件，覆盖当前异常配置，更新内核基准状态。

    - 文件权限异常：尝试修复本地目录读写权限（os.chmod），若修复失败，输出提示并暂停内核。

  - verify_repair()：修复完成后，调用monitor_module的check_abnormal()方法，二次校验内核状态，返回修复结果（成功/失败）。

  - emergency_handle()：连续3次修复失败时，执行紧急处理（停止内核运行、记录紧急日志、输出提示），贴合PRD紧急故障逻辑。

- 修复流程：接收异常信息→获取备份→执行修复→二次校验→修复成功（回归稳定）/修复失败（紧急处理）。

四、存储设计（本地文件系统实现）

采用“本地文件夹+文件”的存储方式，无需数据库，结构极简，适配Python文件操作逻辑，贴合“初步原始核心”的开发需求，同时对应PRD中“核心特征存储库”的基础功能，模拟原核生物的“DNA存储”。

4.1 存储目录结构（Python os模块管理）

根目录：./prokaryote_agent/（可通过配置文件修改），所有子目录由初始化模块自动创建、校验，目录结构如下：

- ./prokaryote_agent/  # 根目录
        

  - config/  # 核心配置目录（存储内核基准配置）
            

    - config.json  # 核心配置文件（JSON格式，存储资源阈值、监测频率、修复次数等）

  - backup/  # 备份目录（存储核心模块、配置的备份，模拟“生物备份机制”）
            

    - module_backup/  # 模块备份目录（存储状态感知、自我修复模块的备份代码/实例）

    - config_backup.json  # 配置备份文件（与config.json同步更新）

  - log/  # 日志目录（存储初始化日志、状态日志、异常日志）
            

    - init.log  # 初始化日志（记录初始化过程、结果）

    - monitor.log  # 状态监测日志（记录实时运行状态）

    - error.log  # 异常日志（记录异常信息、修复过程、修复结果）

4.2 文件格式与内容设计（贴合Python读写）

- config.json（核心配置文件）：JSON格式，易读易修改，Python用json模块读写，示例内容：
       {
  "base_config": {
    "monitor_interval": 1,  # 监测频率（秒）
    "repair_max_count": 3,  # 最大修复次数
    "resource_threshold": {  # 资源阈值（内存MB、CPU%）
      "memory": 500,
      "cpu": 30
    },
    "disk_threshold": 100  # 磁盘可用空间阈值（MB）
  },
  "storage_path": {
    "config_path": "./prokaryote_agent/config/config.json",
    "backup_path": "./prokaryote_agent/backup/",
    "log_path": "./prokaryote_agent/log/"
  }
}

- 备份文件：模块备份为.py文件（存储核心函数/类），配置备份为config_backup.json（与核心配置文件同步），确保修复时可直接调用替换。

- 日志文件：TXT格式，Python用logging模块写入，包含时间戳、模块名称、日志级别、具体内容，便于排查问题，示例：
        [2026-02-02 15:30:00] [MONITOR] [INFO] 内核运行正常，当前内存占用：120MB，CPU占用：15%[2026-02-02 15:30:05] [MONITOR] [ERROR] 异常：状态感知模块报错，异常类型：模块未响应[2026-02-02 15:30:06] [REPAIR] [INFO] 开始修复，读取模块备份文件...

4.3 存储操作规范（Python实现）

- 读写权限：初始化模块启动时，校验所有目录/文件的读写权限，无权限则尝试修复，修复失败终止启动。

- 备份更新：内核启动成功、配置修改后，自动更新备份文件（覆盖旧备份），确保备份数据最新。

- 日志管理：日志文件按天分割（可选，初步版本可按文件大小分割），避免日志文件过大，留存时间≥7天（贴合PRD日志留存要求）。

- 数据安全：文件读写时加锁（Python filelock模块，可选，优先标准库实现），避免并发读写导致数据紊乱（如修复时读取备份文件，同时更新备份）。

五、接口设计（极简Python接口）

接口设计遵循“极简、实用”原则，均为Python函数接口，供开发/运维人员调用，支撑内核启动、运行监测与手动干预，无需复杂参数，贴合初步开发需求。

5.1 核心接口（外部调用）

接口名称

接口功能

Python函数定义

参数说明

返回值

初始化接口

初始化内核，校验存储目录、加载配置与备份

init_prokaryote(config_path=None)

config_path：可选，自定义配置文件路径，默认使用默认路径

dict：{"success": True/False, "msg": "提示信息", "data": 基准状态（成功时）}

启动接口

启动内核，启动状态感知模块，进入稳定运行阶段

start_prokaryote()

无参数（依赖初始化接口的结果）

dict：{"success": True/False, "msg": "提示信息", "pid": 内核进程ID（成功时）}

停止接口

停止内核，停止状态感知模块，保存当前状态与备份

stop_prokaryote(pid=None)

pid：可选，内核进程ID，默认停止当前启动的内核

dict：{"success": True/False, "msg": "提示信息"}

状态查询接口

查询内核当前运行状态、资源消耗、异常记录

query_prokaryote_state()

无参数

dict：{"state": "运行/停止/异常", "resource": 资源消耗, "abnormal": 异常记录（如有）}

5.2 模块间接口（内部调用）

模块间接口为Python内部函数调用，无需外部暴露，极简设计，确保模块联动流畅：

- 初始化模块 → 状态感知模块：传入base_state（基准状态），调用start_monitor()启动监测。

- 状态感知模块 → 自我修复模块：传入abnormal_info（异常信息），调用repair()启动修复。

- 自我修复模块 → 状态感知模块：调用check_abnormal()，获取修复后的状态校验结果。

六、开发环境与依赖

6.1 开发环境

- Python版本：3.13+（推荐3.13，兼容性好、性能稳定）

- 操作系统：Windows 10+/Linux Ubuntu 20.04+/MacOS 12+（支持本地文件系统操作）

- 开发工具：PyCharm（推荐）、VS Code（轻量可选），支持Python代码调试、运行。

6.2 依赖库（优先Python标准库，减少第三方依赖）

- 标准库（必选，无需额外安装）：
        

  - os：本地文件目录操作、权限判断。

  - sys：Python进程、模块操作。

  - threading：状态感知模块的实时监测线程。

  - json：配置文件、备份文件的读写（JSON格式）。

  - logging：日志记录与输出。

- 可选第三方库（按需安装，非必选）：
        

  - psutil：更精准的资源消耗监测（内存、CPU），若无需精准监测，可不用。

  - filelock：文件读写锁，避免并发读写紊乱，初步版本可简化，后续优化添加。

七、关键技术与实现要点

- Python多线程实现实时监测：状态感知模块用threading.Thread创建独立监测线程，设置daemon=True，确保内核停止时监测线程同步停止，避免资源泄漏。

- 本地文件读写优化：采用“只读/只写”模式，避免频繁读写导致文件损坏；配置、备份文件读写时，先写入临时文件，确认成功后再替换原文件，提升安全性。

- 异常处理极简设计：贴合原核生物“简单修复”逻辑，异常类型不复杂，仅处理V0.1必备的异常（模块、配置、文件权限），避免过度设计。

- 轻量性保障：不使用复杂框架、不引入多余依赖，核心代码控制在500行以内（V0.1版本），确保启动快速、资源消耗低。

- 可扩展性预留：模块设计时采用类封装，方法、属性命名规范，后续迭代（V0.2变异模块）可直接在现有架构上添加，无需重构核心代码，贴合PRD迭代路径。

八、版本规划与迭代（贴合PRD）

当前版本（V0.1 原始存活版本）：初步原始核心

核心交付物：Python核心代码（初始化、状态感知、自我修复模块）、本地存储目录、配置文件、日志规范，实现“存活”基础功能，可稳定运行、异常修复。

后续迭代路径（基于本概要设计，贴合PRD）

- V0.2 简单变异版本：添加微小变异模块、简单筛选模块，本地文件系统新增变异记录目录，Python实现低概率随机变异逻辑。

- V0.3 复制迭代版本：添加复制/迭代模块，实现本地文件备份的复制功能，完善模块联动闭环。

- V0.4+ 自我进化版本：优化各模块逻辑，添加人类预设要求配置接口，优化本地文件存储效率，预留群体进化接口。

九、附则

- 本概要设计为prokaryote-agent初步原始核心（V0.1）的开发依据，基于Python+本地文件系统，贴合PRD核心约束与目标，开发过程中可按需微调（需记录变更）。

- 本设计聚焦“可落地、轻量、极简”，不追求复杂功能，优先实现V0.1原始存活版本，后续迭代基于本设计扩展。

- 开发完成后，需配合PRD的验收标准，完成模块测试、闭环测试，确保核心功能达标。
